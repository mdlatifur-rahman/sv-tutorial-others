To help you understand the difference between blocking (=) and non-blocking (<=) assignments in SystemVerilog simulations, here’s a simple time step simulation example. This will illustrate how variables update differently in a clocked process.

Let's say you have the following code in an always block:

### Blocking Assignment Example
```systemverilog
reg a, b, c;

always @(posedge clk) begin
    a = b;
    b = c;
end
```

### Non-Blocking Assignment Example
```systemverilog
reg a, b, c;

always @(posedge clk) begin
    a <= b;
    b <= c;
end
```

Suppose at the positive edge of clk, the values before the assignments are:
- a = 0
- b = 1
- c = 0

#### Time Step Simulation

| Time | Statement         | Blocking (=) Result | Non-blocking (<=) Result |
|------|------------------|---------------------|--------------------------|
| t0   | Initial values   | a=0, b=1, c=0       | a=0, b=1, c=0            |
| t1   | a = b;           | a=1, b=1, c=0       | (no change yet)          |
| t2   | b = c;           | a=1, b=0, c=0       | (no change yet)          |
| t3   | End of block     | a=1, b=0, c=0       | a=1, b=0, c=0            |

**With blocking (=):**
- a is assigned b’s old value (1).
- b is then assigned c’s old value (0).
- So after the always block, a=1, b=0.

**With non-blocking (<=):**
- All right-hand sides are evaluated at the start.
- a will get b’s old value (1) and b will get c’s old value (0), but the assignments happen together at the end of the block.
- So at the end, a=1, b=0.

**The difference is more evident with chained assignments or when a variable is updated and then used again in the same block.**

### Chained Example

```systemverilog
// Initial: a=0, b=1
always @(posedge clk) begin
    a = b;
    b = a;
end
```
- **Blocking:** a=1, then b=a (which is now 1), so b=1 (both end up as 1).
- **Non-blocking:** Both sides use old values. a <= 1; b <= 0; (a=1, b=0 at end).

### Summary Table

| Assignment | Step 1         | Step 2         | At block end      |
|------------|----------------|----------------|-------------------|
| Blocking   | a=b (a=1)      | b=a (b=1)      | a=1, b=1          |
| Non-block  | schedule a=1   | schedule b=0   | a=1, b=0          |

---

**Key takeaway:**  
- Blocking (`=`) executes immediately, possibly affecting subsequent statements.
- Non-blocking (`<=`) schedules assignments for the end of the time step, so all right-hand sides use values from before the block.

If you’d like a specific example from the race.sv file in your repo, let me know!
